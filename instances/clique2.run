reset;

suffix lazy IN;
# option solver cbc;
# option cbc_options ;

option solver cplex;
option cplex_options "time=1800 mipdisplay=1 varsel=4 cutpass=-1";
# option cplex_options "time=1800 mipdisplay=1 varsel=4";

# option solver xpress;
# option xpress_options "outlev=1 symmetry=0 cutstrategy=0";

model clique2.mod;

# pour la trace

# data divorces.dat;
# data wafa.dat;
# data SocialWorkJ.dat;
# data SupremeCourtnot.dat;
# reset data;
# data SupremeCourtyes.dat;
# data south.dat;
# data scotl.dat;
# data netscience.dat;

# option xpress_options "outlev=1 symmetry=0 cutstrategy=0";

param id 						:= 1;
param name 			symbolic 	:= "wafa";
# param name 			symbolic 	:= "south";

# reset data lazy;
# expand;

data ("dat/"&name & ".dat");
# option gentimes 1;

# let{(ir,ib, jr, jb) in RB2}ctr1[ir,ib,jr,jb].lazy:=1;
# let{(ir,ib, jr, jb) in RB2}ctr2[ir,ib,jr,jb].lazy:=1;
# let{(ir,ib, jr, jb) in RB2}ctr3[ir,ib,jr,jb].lazy:=1;
# let{(ir,ib, jr, jb) in RB2}ctr4[ir,ib,jr,jb].lazy:=1;

# display RB2;

solve modularity;

# display _solve_elapsed_time;
# display num0(sub(solve_message, '@*^([0-9]+) branch@*', '\1'));

# display card({(ir, ib, jr, jb) RB cross RB : cut1[ir, ib, jr, jb]>2});
# display card({(ir, ib, jr, jb) RB cross RB : cut2[ir, ib, jr, jb]>2});
# display card({(ir, ib, jr, jb) RB cross RB : cut3[ir, ib, jr, jb]>2});
# display card({(ir, ib, jr, jb) RB cross RB : cut4[ir, ib, jr, jb]>2});
